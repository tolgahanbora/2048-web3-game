"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPostResponse = exports.CreatePostResponseError = void 0;
const web3_js_1 = require("@solana/web3.js");
const constants_js_1 = require("./constants.js");
const actionIdentity_js_1 = require("./actionIdentity.js");
/**
 * Thrown when the Action POST response cannot be created.
 */
class CreatePostResponseError extends Error {
    constructor() {
        super(...arguments);
        this.name = "CreatePostResponseError";
    }
}
exports.CreatePostResponseError = CreatePostResponseError;
/**
 * Create the payload to be returned in an Action POST response,
 * including signing and base64 encoding the `transaction`
 *
 * @throws {CreatePostResponseError}
 */
function createPostResponse({ fields, signers, reference, actionIdentity, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { transaction } = fields;
        if (!transaction.recentBlockhash)
            transaction.recentBlockhash = "11111111111111111111111111111111";
        // Auto-magically detect the identity keypair
        if (!actionIdentity) {
            try {
                actionIdentity = (0, actionIdentity_js_1.getActionIdentityFromEnv)();
            }
            catch (err) {
                // do nothing
            }
        }
        if (transaction.instructions.length <= 0) {
            throw new CreatePostResponseError("at least 1 instruction is required");
        }
        if (actionIdentity) {
            const { instruction, reference: finalReference } = (0, actionIdentity_js_1.createActionIdentifierInstruction)(actionIdentity, reference);
            transaction.add(instruction);
            const memoId = new web3_js_1.PublicKey(constants_js_1.MEMO_PROGRAM_ID);
            const nonMemoIndex = transaction.instructions.findIndex((ix) => ix.programId.toBase58() !== memoId.toBase58());
            if (nonMemoIndex == -1) {
                throw new CreatePostResponseError("transaction requires at least 1 non-memo instruction");
            }
            transaction.instructions[nonMemoIndex].keys.push({
                pubkey: actionIdentity.publicKey,
                isWritable: false,
                isSigner: false,
            });
            transaction.instructions[nonMemoIndex].keys.push({
                pubkey: finalReference,
                isWritable: false,
                isSigner: false,
            });
        }
        if (signers && signers.length)
            transaction.partialSign(...signers);
        return Object.assign(fields, {
            transaction: Buffer.from(transaction.serialize({ requireAllSignatures: false })).toString("base64"),
        });
    });
}
exports.createPostResponse = createPostResponse;
//# sourceMappingURL=createPostResponse.js.map