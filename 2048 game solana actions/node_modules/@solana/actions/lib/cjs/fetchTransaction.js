"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeTransaction = exports.SerializeTransactionError = exports.fetchTransaction = exports.FetchActionError = void 0;
const web3_js_1 = require("@solana/web3.js");
const web3_js_2 = require("@solana/web3.js");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const js_base64_1 = require("js-base64");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
/**
 * Thrown when a transaction response can't be fetched.
 */
class FetchActionError extends Error {
    constructor() {
        super(...arguments);
        this.name = "FetchTransactionError";
    }
}
exports.FetchActionError = FetchActionError;
/**
 * Fetch the action payload from a Solana Action request link.
 *
 * @param connection - A connection to the cluster.
 * @param account - Account that may sign the transaction.
 * @param link - `link` in the Solana Action spec.
 * @param options - Options for `getRecentBlockhash`.
 *
 * @throws {FetchActionError}
 */
function fetchTransaction(connection, link, fields, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, cross_fetch_1.default)(String(link), {
            method: "POST",
            mode: "cors",
            cache: "no-cache",
            credentials: "omit",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
            },
            body: JSON.stringify(fields),
        });
        const json = (yield response.json());
        if (!(json === null || json === void 0 ? void 0 : json.transaction))
            throw new FetchActionError("missing transaction");
        if (typeof json.transaction !== "string")
            throw new FetchActionError("invalid transaction");
        const transaction = yield serializeTransaction(connection, fields.account, json.transaction, options);
        return Object.assign(json, {
            transaction,
        });
    });
}
exports.fetchTransaction = fetchTransaction;
/**
 * Thrown when the base64 encoded action `transaction` cannot be serialized
 */
class SerializeTransactionError extends Error {
    constructor() {
        super(...arguments);
        this.name = "SerializeTransactionError";
    }
}
exports.SerializeTransactionError = SerializeTransactionError;
/**
 * Serialize a base64 encoded transaction into a web3.js `Transaction`.
 *
 * @param connection - A connection to the cluster.
 * @param account - Account that may sign the transaction.
 * @param base64Transaction - `transaction` in the Solana Action spec.
 * @param options - Options for `getRecentBlockhash`.
 *
 * @throws {SerializeTransactionError}
 */
function serializeTransaction(connection, account, base64Transaction, { commitment } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof account === "string")
            account = new web3_js_1.PublicKey(account);
        const transaction = web3_js_2.Transaction.from((0, js_base64_1.toUint8Array)(base64Transaction));
        const { signatures, feePayer, recentBlockhash } = transaction;
        if (signatures.length) {
            if (!feePayer)
                throw new SerializeTransactionError("missing fee payer");
            if (!feePayer.equals(signatures[0].publicKey))
                throw new SerializeTransactionError("invalid fee payer");
            if (!recentBlockhash)
                throw new SerializeTransactionError("missing recent blockhash");
            // A valid signature for everything except `account` must be provided.
            const message = transaction.serializeMessage();
            for (const { signature, publicKey } of signatures) {
                if (signature) {
                    if (!tweetnacl_1.default.sign.detached.verify(message, signature, publicKey.toBuffer()))
                        throw new SerializeTransactionError("invalid signature");
                }
                else if (publicKey.equals(account)) {
                    // If the only signature expected is for `account`, ignore the recent blockhash in the transaction.
                    if (signatures.length === 1) {
                        transaction.recentBlockhash = (yield connection.getRecentBlockhash(commitment)).blockhash;
                    }
                }
                else {
                    throw new SerializeTransactionError("missing signature");
                }
            }
        }
        else {
            // Ignore the fee payer and recent blockhash in the transaction and initialize them.
            transaction.feePayer = account;
            transaction.recentBlockhash = (yield connection.getRecentBlockhash(commitment)).blockhash;
        }
        return transaction;
    });
}
exports.serializeTransaction = serializeTransaction;
//# sourceMappingURL=fetchTransaction.js.map