"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActionIdentityFromEnv = exports.createActionIdentifierInstruction = exports.verifySignatureInfoForIdentity = exports.validateActionIdentifierMemo = exports.ActionIdentifierError = exports.createActionIdentifierMemo = void 0;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const constants_js_1 = require("./constants.js");
const findReference_js_1 = require("./findReference.js");
const ACTIONS_IDENTITY_SCHEMA = {
    separator: ":",
    protocol: constants_js_1.SOLANA_ACTIONS_PROTOCOL.replace(":", ""),
    /** avoids magic numbers */
    scheme: {
        protocol: 0,
        identity: 1,
        reference: 2,
        signature: 3,
    },
};
function createActionIdentifierMemo(identity, reference) {
    const signature = tweetnacl_1.default.sign.detached(reference.toBytes(), identity.secretKey);
    const identifier = new Array(Object.keys(ACTIONS_IDENTITY_SCHEMA.scheme).length);
    identifier[ACTIONS_IDENTITY_SCHEMA.scheme.protocol] =
        ACTIONS_IDENTITY_SCHEMA.protocol;
    identifier[ACTIONS_IDENTITY_SCHEMA.scheme.identity] =
        identity.publicKey.toBase58();
    identifier[ACTIONS_IDENTITY_SCHEMA.scheme.reference] = reference.toBase58();
    identifier[ACTIONS_IDENTITY_SCHEMA.scheme.signature] = bs58_1.default.encode(signature);
    // todo: we should likely have a test to make sure this never exceeds the memo instruction limit
    // "up to 566 bytes" per https://spl.solana.com/memo#compute-limits
    // these are normally < 200 bytes
    // console.log('length:', Buffer.from(memo, 'utf-8').length);
    return identifier.join(ACTIONS_IDENTITY_SCHEMA.separator);
}
exports.createActionIdentifierMemo = createActionIdentifierMemo;
/**
 * Thrown when the Action POST response cannot be created.
 */
class ActionIdentifierError extends Error {
    constructor() {
        super(...arguments);
        this.name = "CreatePostResponseError";
    }
}
exports.ActionIdentifierError = ActionIdentifierError;
function validateActionIdentifierMemo(identity, memos) {
    var _a;
    if (!memos)
        return false;
    // web3js SignatureResultInfo can have multiple memos in the response
    // each memo is semi-colon separated
    if (typeof memos == "string")
        memos = memos.split(";");
    for (let i = 0; i < memos.length; i++) {
        try {
            let memo = memos[i].trim();
            // Remove the Memo program's byte count prefix
            if (/^\[\d+\] /.test(memo)) {
                memo = ((_a = memo.match(/^\[\d+\] (.*)/)) === null || _a === void 0 ? void 0 : _a[1].trim()) || memo;
            }
            if (/^([\w\d]+:){2,}/g.test(memo) == false) {
                throw new ActionIdentifierError("invalid memo formatting");
            }
            const identifier = memo.split(ACTIONS_IDENTITY_SCHEMA.separator);
            if (identifier.length !== Object.keys(ACTIONS_IDENTITY_SCHEMA.scheme).length) {
                throw new ActionIdentifierError("invalid memo length");
            }
            // todo: ? verify the identifier protocol matches the desired one (i.e. ACTIONS_IDENTITY_SCHEMA.protocol)
            // const protocol = identifier[ACTIONS_IDENTITY_SCHEMA.scheme.protocol];
            let memoIdentity;
            try {
                memoIdentity = new web3_js_1.PublicKey(identifier[ACTIONS_IDENTITY_SCHEMA.scheme.identity]);
            }
            catch (err) {
                throw new ActionIdentifierError("malformed memo identity");
            }
            if (!memoIdentity)
                throw new ActionIdentifierError("invalid memo identity");
            if (memoIdentity.toBase58() !== identity.toBase58()) {
                throw new ActionIdentifierError("identity mismatch");
            }
            const verified = tweetnacl_1.default.sign.detached.verify(bs58_1.default.decode(identifier[ACTIONS_IDENTITY_SCHEMA.scheme.reference]), bs58_1.default.decode(identifier[ACTIONS_IDENTITY_SCHEMA.scheme.signature]), identity.toBytes());
            if (verified) {
                return {
                    verified: true,
                    reference: identifier[ACTIONS_IDENTITY_SCHEMA.scheme.reference],
                };
            }
        }
        catch (err) {
            // do nothing
        }
    }
    return false;
}
exports.validateActionIdentifierMemo = validateActionIdentifierMemo;
function verifySignatureInfoForIdentity(connection, identity, sigInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const validated = validateActionIdentifierMemo(identity.publicKey, sigInfo.memo);
            if (!validated)
                return false;
            const confirmedSigInfo = yield (0, findReference_js_1.findReference)(connection, new web3_js_1.PublicKey(validated.reference));
            if (confirmedSigInfo.signature === sigInfo.signature)
                return true;
        }
        catch (err) {
            //do nothing
        }
        return false;
    });
}
exports.verifySignatureInfoForIdentity = verifySignatureInfoForIdentity;
/**
 *
 */
function createActionIdentifierInstruction(identity, reference = new web3_js_1.Keypair().publicKey) {
    const memo = createActionIdentifierMemo(identity, reference);
    return {
        memo,
        reference,
        instruction: new web3_js_1.TransactionInstruction({
            programId: new web3_js_1.PublicKey(constants_js_1.MEMO_PROGRAM_ID),
            data: Buffer.from(memo, "utf8"),
            // Adding any keys will trigger the memo instruction to require they sign
            // which would implicitly result in a transaction failure since they are not signing
            keys: [],
        }),
    };
}
exports.createActionIdentifierInstruction = createActionIdentifierInstruction;
function getActionIdentityFromEnv(envKey = "ACTION_IDENTITY_SECRET") {
    try {
        if (!process.env[envKey])
            throw Error("missing env key");
        // todo: maybe add in some error checks
        return web3_js_1.Keypair.fromSecretKey(Buffer.from(JSON.parse(process.env[envKey])));
    }
    catch (err) {
        throw new Error(`invalid identity in env variable: '${envKey}'`);
    }
}
exports.getActionIdentityFromEnv = getActionIdentityFromEnv;
//# sourceMappingURL=actionIdentity.js.map