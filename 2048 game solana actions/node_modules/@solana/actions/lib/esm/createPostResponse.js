import { PublicKey } from "@solana/web3.js";
import { MEMO_PROGRAM_ID } from "./constants.js";
import { createActionIdentifierInstruction, getActionIdentityFromEnv, } from "./actionIdentity.js";
/**
 * Thrown when the Action POST response cannot be created.
 */
export class CreatePostResponseError extends Error {
    constructor() {
        super(...arguments);
        this.name = "CreatePostResponseError";
    }
}
/**
 * Create the payload to be returned in an Action POST response,
 * including signing and base64 encoding the `transaction`
 *
 * @throws {CreatePostResponseError}
 */
export async function createPostResponse({ fields, signers, reference, actionIdentity, }) {
    const { transaction } = fields;
    if (!transaction.recentBlockhash)
        transaction.recentBlockhash = "11111111111111111111111111111111";
    // Auto-magically detect the identity keypair
    if (!actionIdentity) {
        try {
            actionIdentity = getActionIdentityFromEnv();
        }
        catch (err) {
            // do nothing
        }
    }
    if (transaction.instructions.length <= 0) {
        throw new CreatePostResponseError("at least 1 instruction is required");
    }
    if (actionIdentity) {
        const { instruction, reference: finalReference } = createActionIdentifierInstruction(actionIdentity, reference);
        transaction.add(instruction);
        const memoId = new PublicKey(MEMO_PROGRAM_ID);
        const nonMemoIndex = transaction.instructions.findIndex((ix) => ix.programId.toBase58() !== memoId.toBase58());
        if (nonMemoIndex == -1) {
            throw new CreatePostResponseError("transaction requires at least 1 non-memo instruction");
        }
        transaction.instructions[nonMemoIndex].keys.push({
            pubkey: actionIdentity.publicKey,
            isWritable: false,
            isSigner: false,
        });
        transaction.instructions[nonMemoIndex].keys.push({
            pubkey: finalReference,
            isWritable: false,
            isSigner: false,
        });
    }
    if (signers && signers.length)
        transaction.partialSign(...signers);
    return Object.assign(fields, {
        transaction: Buffer.from(transaction.serialize({ requireAllSignatures: false })).toString("base64"),
    });
}
//# sourceMappingURL=createPostResponse.js.map